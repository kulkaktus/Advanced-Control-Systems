function [K,sol_info] = condes (inG , inphi , inper , options)
%
% CONDES is used to design a robust controller based on the controller
% structure defined by phi and control performance specified in per for the
% set of models given in G.
%
%   [K sol]=condes(G,phi,per,opt) or K=condes(G,phi,per)
%
% G :   is a SISO or MIMO LTI model, identified model (idmodel) or a frequency 
%       domain model (FRD). For the idmodels the frequency domain uncertainty 
%       is automatically taken into account for controller design. G 
%       can be a cell such that G{j} is the j-th model. The controller will
%       meet the specifications for all models. 
%
% phi : is generated by CONPHI command and contains the controller
%       structure. For a MIMO controller, phi is a cell containing the structure
%       of each SISO controller in the MIMO system (e.g. phi{i,j} is the structure 
%       of controller between the i-th output and the j-th input). If only
%       one phi is defined, it will be used for all controllers.
%
% per : is generated by CONPER and defines the control performance. For
%       multimodel systems per can be a cell such that per{j} defines the control 
%       performance for the j-th model G{j}. For MIMO systems, per can be a 
%       cell such that per{q} is the performance specification for L{q,q}.
%       For MIMO multimodel systems per{j}{q} defines the performance of L{q,q}
%       of the j-th MIMO model G{j}. If only one per is defined, it will be 
%       used for all models and outputs.
%
% opt : is generated by CONDESOPT and defines the options for controller
%       design. If it is not defined the default values will be used.
%
% K :   is the designed controller (SISO or MIMO transfer function). For
%       gain-scheduled controller design K is a cell and 
%                K(theta)=K{1} + theta * K{2} + ...
%
% sol : is a structure containing some information about the optimization
%       problem and its results:
%
%       sol.rho :       vector of controller parameters
%       sol.A, sol.b :  give the linear constraints as A*rho<b
%       sol.optval :    optimal value of the optimization criterion for
%                       linprog and quadprog and the optimazation results
%                       for Yalmip
%       sol.gamma :     optimal gamma in Hinf control
%       sol.xflag :     output flag of the optimization problem 
%
%

if nargin < 4
    options = condesopt;
end

[Gf,Gdim,phi,n,phif,phifd,per,w,N,performance,Ldf,LDf,FGf,FLdf,FLDf,CovGf] = condesdata (inG,inphi,inper,options);


m=Gdim(1); no=Gdim(2); ni=Gdim(3);

if no==1 && ni==1 % check stability of SISO systems
    check_Ld_stability(per,inG,phi);
end


%------- Gain scheduled vector construction -------------------------------
theta=options.gs;
delta=options.np;

if ~isempty(theta)
    [rowtheta,coltheta]=size(theta);
    if rowtheta~=m, 
         error('The number of rows of the scheduling parameter matrix should be equal to the number of models')
    end
end

theta_bar=ones(m,1);
for j=1:length(delta)
    for i=1:delta(j)
        theta_bar=[theta_bar theta(:,j).^i];
    end
end

Ngs=sum(delta)+1;

ntot=Ngs*sum(sum(n));

%--------------------------------------------------------------------------

%---------------Computing index for the vector of controller parameters----
for p=1:ni
    for q=1:no
        nn=Ngs*(sum(sum(n(1:p-1,:)))+sum(n(p,1:q-1)));
        rhoIndex{p,q}=nn+1:nn+Ngs*n(p,q);
    end
end


%-----------------------Solver choice- ------------------------------------

if (strcmp(options.yalmip,'on') | isempty(options.nq)| (no > 2 & strcmp(options.Gbands,'on'))) & exist('yalmip')>1 % Use YALMIP interface
        
    rho=sdpvar(ntot,1);
    YesYalmip=1;
                   
                % Here we put the controller parameters of q-th column of
                % the controller (for MIMO systems) into rhod{q}

    for q=1:no,
        rhod{q}=[];
        for p=1:ni,
            rhod{q}=[rhod{q};rho(rhoIndex{p,q})];
        end
    end
    
            % Here we set the solver options
    
    ops=sdpsettings('solver','sdpt3','verbose',0);
    if ~isempty (options.solveroptions)
        names = fieldnames(options.solveroptions);
        for k=1:length(names);
            ops = sdpsettings (ops , names{k} , options.solveroptions.(names{k}));
        end
    end
    
else  % Use optimization toolbox
    
    YesYalmip=0;
    rho=zeros(ntot,1);
    
    if isempty(options.nq)
        warning('Yalmip not found. Setting nq to 8')
        options.nq=8;
    end
    
    ops = optimset;
    if ~isempty (options.solveroptions)
        names = fieldnames(options.solveroptions);
        for k=1:length(names);
            ops = optimset (ops , names{k} , options.solveroptions.(names{k}));
        end
        
    end
       
    
end

%--------------------------------------------------------------------------


%---- gamma iteration parameters for H infinity control -------------------


if isempty ( options.gamma ),
    gamma=[];
else
    g_min=options.gamma(1);
    
    if g_min <= 0,
        error('The minimum of gamma should be greater than zero');
    end
    
    g_max=options.gamma(2);
    
    if g_max <= g_min,
        error('The maximum of gamma should be greater than its minimum');
    end
    
    g_tol=options.gamma(3);
    
    if g_tol <= 0,
        error('The tolerance of gamma should be greater than zero');
    end
    
    
    gamma=g_max;
end

lambda = options.lambda;
if min(lambda) <0,
       error('All elements of lambda should be non negative'); 
end 

nq=options.nq;
if ~isempty(nq)
    if nq < 3,
        error('nq should be an integer greater than 2');
    end
end

%--------------------------------------------------------------------------

HinfConstraint=[]; 
A=[];
b=[];


if ni==1 & no==1  % SISO model
    
    
%--------- Compute phi*G and the quadratic criterion |F(L-Ld)|--------------  


phiGfreq=cell(1,m);
toto=cell(1,m);
FphiGf=cell(1,m);
totod=cell(1,m);
H=zeros(ntot,ntot);
f=zeros(ntot,1);

for j=1:m
    for u=1:n
        toto{j}(u,:)=phif{j}(u,1,:).*Gf{j}(:,:,:);
        phiGfreq{j}((u-1)*Ngs+1:u*Ngs,:)=kron(theta_bar(j,:)',toto{j}(u,:));
        
        if ~isempty(Ldf)
            totod{j}(u,:)=squeeze(phifd{j}(u,1,:)).*FGf{j};
            FphiGf{j}((u-1)*Ngs+1:u*Ngs,:)=kron(theta_bar(j,:)',totod{j}(u,:));
        end
    end
    
    if ~isempty(Ldf)
        H = H + real( FphiGf{j}*FphiGf{j}');
        f = f + transpose( -real(FLdf{j}.' * FphiGf{j}') );
    end
    
end
    
    
%--------- Compute uncertainty polygon for identified models --------------  
   

if isempty(nq)
    nqq=8;
else
    nqq=nq;
end


% The covariance matrix of the frequency-domain response is
% presented by an ellips in the Nyquist diagram. In this part, the vertices 
% of a nqq-side polygon circumscribing this ellips is computed. The constraints
% will be satisfied for the vertices of the polygon instead for its center.
% x0 and y0 are the coordinates of a regular polygon circumscribing a circle
% with a radius of 2.4474 times the standard deviation of the estimates 
% (95 percent confidence interval).

i=sqrt(-1);

for j=1:m
    
    if ~isempty(CovGf{j})
        for q=1:nqq
                x0=real(2.4474 * exp(i*2*pi*q/nqq)/cos(pi/nqq));
                y0=imag(2.4474 * exp(i*2*pi*q/nqq)/cos(pi/nqq));
            for p=1:ntot
                 for k=1:N(j)
                    Sigma(k,:,:)=sqrtm((squeeze(CovGf{j}(1,1,k,:,:))));
                    Pxy{j}(k)=[1 i]*squeeze(Sigma(k,:,:))*[x0;y0];
                end
                phiCov{j}{q}(p,:)=phiGfreq{j}(p,:).*(1+Pxy{j}./squeeze(Gf{j})');
            end
            
        end
        
    else
        phiCov{j}{1}=phiGfreq{j};
        nqq=1;
    end
end

 
%--------------------------------------------------------------------------

    switch performance
        
%-------------------------GPhC controller----------------------------------
        
        case 'GPhC'
            
            gm=zeros(1,m); pm=zeros(1,m); el=zeros(1,m);
            alphad=zeros(1,m); wc=zeros(1,m); wcn=zeros(1,m);betad=zeros(1,m);
           
            
            for j=1:m
                
                gm(j)=per{j}.par(1);
                pm(j)=per{j}.par(2);
                el(j)=(1-1/gm(j));
                alphad(j)= fzero(@(x) alpha_finder_degree(x,el(j),pm(j)),pm(j));
                
                
                
                if isempty(options.beta),
                    betad(j)=45-pm(j)/2;
                else
                    betad(j)=options.beta;
                end
                
                nowc(j)=1;
                wcn(j)=1;
                
                
                if length(per{j}.par) > 2
                    
                    wc(j)=per{j}.par(3);
                    if wc(j) >= 0
                        [ntoto , wcn(j)] = min(abs(w{j}-wc(j)));
                        nowc(j)=0;
                    end
                    
                end
                
                
            end
            alpha=alphad*pi/180;
            beta=betad*pi/180;
            
            a_d1=[sin(alpha') -cos(alpha')];
            d_d1= -sin(alpha').*(1-el');
            
            a_d2=-[tan(beta') ones(m,1)];
            d_d2=1./cos(beta');
            
            for j=1:m
                                
                if nowc(j)==0
                    for k=1:nqq
                        [A1 b1]= Ab_construct (phiCov{j}{k}(:,1:wcn(j)-1) , a_d2(j,:) , d_d2(j)); % under d2
                        
                        [A2 b2]= Ab_construct (phiCov{j}{k}(:,wcn(j):N(j)) , -a_d2(j,:) , -d_d2(j)); % above d2
                        
                        [A3 b3]= Ab_construct (phiCov{j}{k}(:,wcn(j):N(j)) , a_d1(j,:) , d_d1(j)); % right of d1
                        
                        A=[A;A1;A2;A3];
                        b=[b;b1;b2;b3];
                    end
                else
                    for k=1:nqq
                        [A3 b3]= Ab_construct (phiCov{j}{k}(:,wcn(j):N(j)) , a_d1(j,:) , d_d1(j)); % right of d1
                        A=[A;A3];
                        b=[b;b3];
                    end
                end
                
                
            end
            
            if length(per{1}.par) > 3
                
                Ku=per{1}.par(4);
                wh=per{1}.par(5);
                for j=1:m
                    
                    [A_b b_b] = Ab_for_bounded_K (phif{j}, w{j}, Ku, wh, theta_bar(j,:));
                    
                    A = [A ; A_b];
                    b = [b ; b_b];
                end
            end
            
            
            if isempty(Ldf)  % Ld is not considered
                
                f=zeros(Ngs*n,1);
                H=[];
            
                switch inphi.ConType
                    
                    case {'PID' , 'PIDd', 'PI' , 'PId' }
                        sgn = test_PID_ss_gain(Gf,w);
                        f(Ngs+1:2*Ngs) = sgn * sum(theta_bar)./m ; % maximizes/minimizes ki
                        
                    case {'PD' , 'PDd', 'P' , 'Pd'}
                        sgn = test_PID_ss_gain(Gf,w);
                        f(1:Ngs) = sgn * sum(theta_bar)./m ; % maximizes kp
                        
                    case 'Laguerre'
                        
                        xi=inphi.par(1);
                        order=inphi.par(2);
                        
                        f(1)=-1;
                        f(2:order+1)=-sqrt(2*xi)/xi;
                        for u=2:order+1
                            f(u)=f(u)*(-1)^u;
                        end
                    case 'Laguerred'
                        
                        a=inphi.par(1);
                        order=inphi.par(2);
                        
                        f(1)=-1;
                        f(2:order+1)=-sqrt(1-a^2)/(1-a);
                        
                    otherwise   
                         
                        warning('No optimization is performed. Specify Ld for minimizing L-Ld.')

                end                              
                
            end
            
            [x,optval,xflag] = solveopt(H,f,A,b,[],YesYalmip,rho,ops);
                                   
            
            %---------------Loop-shaping controller------------------------------------
            
        case 'LS'
             
            Mm=zeros(1,m);
            a=cell(1,m); d=cell(1,m);        
            
            for j=1:m
                
                Mm(j)=per{j}.par(1);
                a{j}(:,1)=real(Ldf{j})+1;
                a{j}(:,2)=imag(Ldf{j});
                d{j}=-a{j}(:,1)+Mm(j)*abs(Ldf{j}+1);
                for k=1:nqq             
                    [A1 b1]= Ab_construct (phiCov{j}{k} , a{j} , d{j});  % right side of the line a(w).x = d(w)
                    A=[A;A1];
                    b=[b;b1];
                end
             end
            
            
            
            if length(per{1}.par) > 1
                
                Ku=per{1}.par(2);
                wh=per{1}.par(3);
                for j=1:m
                    [A_b b_b] = Ab_for_bounded_K (phif{j}, w{j}, Ku, wh, theta_bar(j,:));
                    
                    A = [A ; A_b];
                    b = [b ; b_b];
                end
            end
                       
            [x,optval,xflag] = solveopt(H,f,A,b,[],YesYalmip,rho,ops);
             
            
            %-------------H infinity controller----------------------------------------
            
        case 'Hinf'
            
            a=cell(1,m); d=cell(1,m);
             

                       
            for j=1:m
                
                W{j}=per{j}.par;
                
                for k=1:4
                    if isempty(W{j}{k})
                        Wf{j}(:,k)=zeros(N(j),1);
                    elseif strcmp(class(W{j}{k}),'frd')
                        w1=W{j}{k}.Frequency;
                        x1=W{j}{k}.ResponseData;
                        Wf{j}(:,k)=interp1(w1,x1(:),w{j},[],'extrap');
                    else
                        Wf{j}(:,k)=freqresp(W{j}{k},w{j});
                    end
                    if k==3, Wf{j}(:,3)=Wf{j}(:,3)./squeeze(Gf{j}); end
                    if k==4, Wf{j}(:,4)=Wf{j}(:,4).*squeeze(Gf{j}); end
                end                
                                
                
                a{j}(:,1)=real(Ldf{j})+1;
                a{j}(:,2)=imag(Ldf{j});
                                
                
                           
                
                if isempty(gamma),
                    for k=1:nqq
                        if ~isempty(nq)
                            [A1 b1 HinfConstraint1]=Ab_HinfCons(phiCov{j}{k},Wf{j},Ldf{j},nq,lambda);
                        else
                            [A1 b1 HinfConstraint1]=Ab_HinfCons(phiCov{j}{k},Wf{j},Ldf{j},nq,lambda,rho);
                        end
                        A=[A ; A1];
                        b=[b ; b1];
                        HinfConstraint=[HinfConstraint HinfConstraint1];
                    end
                end
                
            end
            
            
            
            if isempty(gamma),  % Minimizing L-Ld under H infinity constraints
                
                
                [x,optval,xflag] = solveopt(H,f,A,b,HinfConstraint,YesYalmip,rho,ops);
                              
                
            else
                
%------------ Bisection algorithm to minimize gamma------------------------

                gamma_opt=0;
                gamma_opt_old = g_max + g_tol + 1;
                nit = 0;

                while gamma_opt_old - gamma_opt > g_tol
                    
                    nit = nit+1;
                    if nit ~= 1
                        if gamma_opt~=0
                            gamma_opt_old = gamma_opt;
                            g_min=options.gamma(1);
                            g_max=gamma_opt;
                            for j=1:m, 
                                Ldf{j}=transpose(phiGfreq{j})*x_opt; 
                            end
                        else
                            break;
                        end
                    end

                    while g_max-g_min > g_tol

                        A=[];
                        b=[];

                        HinfConstraint=[];

                        for j=1:m

                            if sum(lambda)==0
                                Wfgamma{j}=inv(gamma)*Wf{j};
                            else

                                for k=1:4,
                                    if lambda(k)~=0
                                        Wfgamma{j}(:,k)=inv(gamma)*Wf{j}(:,k);
                                    else
                                        Wfgamma{j}(:,k)=Wf{j}(:,k);
                                    end
                                end
                            end


                            for k=1:nqq
                                if ~isempty(nq)
                                    [A1 b1 HinfConstraint1]=Ab_HinfCons(phiCov{j}{k},Wfgamma{j},Ldf{j},nq,lambda);
                                else
                                    [A1 b1 HinfConstraint1]=Ab_HinfCons(phiCov{j}{k},Wfgamma{j},Ldf{j},nq,lambda,rho);
                                end
                                A=[A ; A1];
                                b=[b ; b1];
                                HinfConstraint=[HinfConstraint HinfConstraint1];
                            end

                        end

                        [x,optval,xflag] = solveopt([],zeros(ntot,1),A,b,HinfConstraint,YesYalmip,rho,ops);

                        if xflag==1,

                            x_opt=x;gamma_opt=gamma;optval_opt=optval;xflag_opt=xflag;

                            g_max=gamma;
                            disp(['gamma=', num2str(g_max)])
                            gamma=mean([g_min,gamma]);
                            %gamma=mean([options.gamma(1),gamma]);

                            
                        else
                            g_min=gamma;
                            gamma=mean([g_max,gamma]);
                        end

                    end
                    
                    
                end

                if gamma_opt~=0
                    x=x_opt;gamma=gamma_opt;optval=optval_opt;xflag=xflag_opt;
                end
                
                %--------------------------------------------------------------------------
                
            end
            
            
    end
    
    
    for k=1:n
        rhox(k,:)=x((k-1)*Ngs+1:k*Ngs);
    end
    
    
    if ~isempty(theta)
        fprintf('\n');
        disp('K{1}+theta_1 K{2}+theta_2 K{3} + ... +theta_1^2 k{n}+theta_2^2k{n+1}+...')
        fprintf('\n');
        for k=1:Ngs
            K{k} = reduced_order(rhox(:,k),phi,inphi.ConType);
            disp(['K{'  int2str(k) '}=']),K{k}
        end
    else
        K = reduced_order(rhox,phi,inphi.ConType);
    end
    
    
%===============================================MIMO======================================
%=========================================================================================
else % if MIMO
    
    
 % Computing the quadratic optimization criterion (norm of F(L-Ld))
    
    H=zeros(ntot,ntot);
    f=zeros(ntot,1);
    Ldf_mat=cell(1,m);
    
    for j=1:m
        
        Nd(j)=length(FGf{j});
        H2=zeros(ntot,ntot);
        f2=zeros(ntot,1);
        for p=1:no
            
            Ldf_mat{j}(:,p)=LDf{j}(p,p,:);
            
            for q=1:no
                
                LDfpq_row=zeros(1,Nd(j));
                Sai=zeros(ntot,Nd(j));
                for u=1:ni
                    
                    Phi=zeros(ntot,Nd(j));
                    phif_mat=zeros(n(u,q),Nd(j));
                    Gf_row=zeros(1,Nd(j));                  
                    
                    phif_mat(:,:)=phifd{j}{u,q}(:,1,:);
                    Gf_row(1,:)=FGf{j}(p,u,:);
                    Gf_mat=ones(n(u,q),1)*Gf_row;
                    
                    Phi(rhoIndex{u,q},:)=kron(phif_mat.*Gf_mat,theta_bar(j,:)');
                    Sai=Sai+Phi;
                end
                
                H1=2*real(Sai*Sai');  % this real is just for removing numerical errors
                
                LDfpq_row(1,:)=FLDf{j}(p,q,:);
                f1=transpose( -2*real(LDfpq_row*Sai') );
                
                H2=H2+H1;
                f2=f2+f1;
            end
        end
        
        H=H+H2;
        f=f+f2;
    end
    
    
    StabCons=[];    
    
    if strcmp(options.Gbands,'on')
        
        %-------------------------  Gershgorin stability conditions  -------------
        
        if no > 1, % No Gershgorin band needed
            
            
            for j=1:m,
                
                % Here we compute  G*Phi such that L(p,q)=rhod{q}'*Gphi{p,q}
                Gphi=cell(no,no);
                toto1=zeros(1,N(j));
                toto2=[];
                for q=1:no
                    for p=1:ni
                        toto1(1,:)=Gf{j}(q,p,:);
                        for k=1:no
                            toto2(:,:)=phif{j}{p,k}(:,:,:);
                            for u=1:n(p,k),
                                Gphi{q,k}=[Gphi{q,k};kron(theta_bar(j,:)',toto1.*toto2(u,:))];
                            end
                        end
                    end
                end
                
                if no==2 && ~isempty(nq)
                    
                    for q=1:no
                        
                        a{j,q}(:,1)=real(Ldf_mat{j}(:,q))+1;
                        a{j,q}(:,2)=imag(Ldf_mat{j}(:,q));
                        d{j,q}(:,1)=-a{j,q}(:,1);
                    end
                    
                    i=sqrt(-1);
                    for k=1:nq
                        Gphif_r1 = [Gphi{1,1};exp(i*2*pi*k/nq)/cos(pi/nq) * Gphi{1,2}];
                        
                        if ni==1
                            Gphif_x=[Gphif_r1(rhoIndex{1,1},:);Gphif_r1(rhoIndex{1,2},:)];
                        else
                            Gphif_x=[Gphif_r1(rhoIndex{1,1},:);Gphif_r1(rhoIndex{2,1},:);Gphif_r1(rhoIndex{1,2},:);Gphif_r1(rhoIndex{2,2},:)];
                        end
                        [Aq , bq] = Ab_construct (Gphif_x,a{j,1},d{j,1});  % right side of ax=d
                        
                        A=[A;Aq];
                        b=[b;bq];
                        
                        Gphif_r2 = [exp(i*2*pi*k/nq)/cos(pi/nq)* Gphi{2,1}; Gphi{2,2}];
                        
                        if ni==1
                            Gphif_x=[Gphif_r2(rhoIndex{1,1},:);Gphif_r2(rhoIndex{1,2},:)];
                        else
                            Gphif_x=[Gphif_r2(rhoIndex{1,1},:);Gphif_r2(rhoIndex{2,1},:);Gphif_r2(rhoIndex{1,2},:);Gphif_r2(rhoIndex{2,2},:)];
                        end
                        
                        
                        [Aq , bq] = Ab_construct (Gphif_x,a{j,2},d{j,2});  % right side of ax=d
                        
                        A=[A;Aq];
                        b=[b;bq];
                        
                    end
                else
                    
                    % Here we compute Gershgorin bands r(q) and set the
                    % constraints
                    
                    if exist('yalmip')==0,
                        error('You need YALMIP for this problem')
                    end
                    
                    
                    for q=1:no,
                        for k=1:N(j),
                            r=[];
                            for p=1:no,
                                if p~=q,
                                    r=[ r  abs(rhod{q}'*Gphi{p,q}(:,k))];
                                end
                            end
                            try
                                StabCons= [StabCons, (sum(r)*abs(1+Ldf_mat{j}(k,q))-real((1+conj(Ldf_mat{j}(k,q)))*(1+rhod{q}'*Gphi{q,q}(:,k))) <= 0)];
                            catch
                                StabCons= StabCons+ set(sum(r)*abs(1+Ldf_mat{j}(k,q))-real((1+conj(Ldf_mat{j}(k,q)))*(1+rhod{q}'*Gphi{q,q}(:,k))) < 0);
                            end
                        end
                    end
                end
                
            end
            
        end
        
    end
    
    switch performance
        
        
% -------------------------GPhC MIMO controller---------------------------------
              
        case 'GPhC'
            gm=zeros(m,no); pm=zeros(m,no); el=zeros(m,no); alpha=zeros(m,no);
            wc=zeros(m,no); wcn=zeros(m,no);beta=zeros(m,no);
            a_d1=cell(m,no); a_d2=cell(m,no); d_d1=cell(m,no); d_d2=cell(m,no);
            
            for j=1:m
                for q=1:no
                                        
                    gm(j,q)=per{j}{q}.par(1);
                    pm(j,q)=per{j}{q}.par(2);
                    
                    el(j,q)=(1-1/gm(j,q));
                    alphad= fzero(@(x) alpha_finder_degree(x,el(j,q),pm(j,q)),pm(j,q));
                    alpha(j,q)=alphad*pi/180;
                    
                    
                    if isempty(options.beta),
                        beta(j,q)=45-pm(j,q)/2;
                    else
                        beta(j,q)=options.beta;
                    end
                    
                    
                    wcn(j,q)=1;
                    
                    if length(per{j}{q}.par) > 2
                        
                        wc(j,q)=per{j}{q}.par(3);
                        
                        if wc(j,q) >= 0
                            [ntoto , wcn(j,q)] = min(abs(w{j}-wc(j,q)));
                        end
                        
                    end
                    
                    
                    a_d1{j,q}=[sin(alpha(j,q)) -cos(alpha(j,q))];
                    d_d1{j,q}= -sin(alpha(j,q))*(1-el(j,q));
                    
                    
                    a_d2{j,q}=[-tan(beta(j,q)*pi/180) -1];
                    d_d2{j,q}= 1/cos(beta(j,q)*pi/180);
                    
                end
            end
             
            for j=1:m
                for q=1:no
                    
                    if wcn(j,q) > 1
                        Gphif_temp = Gphif_construct_MIMO (Gf{j},phif{j},w{j},w{j}(1:wcn(j,q)-1),q,n,theta_bar(j,:)); 
                        [A1 , b1]=Ab_construct (Gphif_temp,a_d2{j,q},d_d2{j,q});  % under d2
                        Gphif_temp= Gphif_construct_MIMO (Gf{j},phif{j},w{j},w{j}(wcn(j,q):N(j)),q,n,theta_bar(j,:)); 
                        [A2 , b2] = Ab_construct (Gphif_temp,-a_d2{j,q},-d_d2{j,q});  % above d2
                        A=[A ; A1 ; A2];
                        b=[b ; b1 ; b2];
                    end
                    
                    Gphif_temp = Gphif_construct_MIMO (Gf{j},phif{j},w{j},w{j}(wcn(j,q):N(j)),q,n,theta_bar(j,:)); 
                    [A3 , b3] = Ab_construct (Gphif_temp,a_d1{j,q},d_d1{j,q});  % right of d1
                    A = [A ; A3];
                    b = [b ; b3];
                 end
            end
            
   % Limit for real and imaginary parts of the controller
            if length(per{1}{1}.par) > 3
                
                Ku=per{1}{1}.par(4);
                wh=per{1}{1}.par(5);
                
                [A_b,b_b]=gain_bound_MIMO(phif,w,Ku,wh,theta_bar,Gdim,ntot,rhoIndex)               
                                
                A= [A ; A_b];
                b= [b ; b_b];
            end           
                                    
            [x,optval,xflag]=solveopt(H,f,A,b,StabCons,YesYalmip,rho,ops);
                        
            
        case 'LS'
            
  % -------------------------Loop shaping MIMO controller---------------------------------
            
            
            Mm=zeros(m,no); a=cell(m,no); d=cell(m,no);
             
            for j=1:m
                for q=1:no
                    
                    Mm(j,q)=per{j}{q}.par(1);
                    a{j,q}(:,1)=real(Ldf_mat{j}(:,q))+1;
                    a{j,q}(:,2)=imag(Ldf_mat{j}(:,q));
                    d{j,q}(:,1)=-a{j,q}(:,1)+Mm(j,q)*abs(Ldf_mat{j}(:,q)+1);
                    
                    
                    Gphif_temp = Gphif_construct_MIMO (Gf{j},phif{j},w{j},w{j},q,n,theta_bar(j,:)); 
                    
                    [Aq , bq] = Ab_construct (Gphif_temp,a{j,q},d{j,q});  % right side of ax=d
                    
                    A=[A;Aq];
                    b=[b;bq];
                    
                 end
            end
            
            
            if length(per{1}{1}.par) > 1
                
                Ku=per{1}{1}.par(2);
                wh=per{1}{1}.par(3);
                
                [A_b,b_b]=gain_bound_MIMO(phif,w,Ku,wh,theta_bar,Gdim,ntot,rhoIndex);
                
                
                A= [A ; A_b];
                b= [b ; b_b];                
                
            end
            
            [x,optval,xflag]=solveopt(H,f,A,b,StabCons,YesYalmip,rho,ops);
    

          
        case 'Hinf'
            
           % ------------------------ H infinity MIMO controller ---------------------------------

                       
            a=cell(m,no); d=cell(m,no);                                                       
            Gphif=cell(m,no);
            
            for j=1:m
                for q=1:no
                    
                    W{j}=per{j}{q}.par;
                    
                    for k=1:4
                        if isempty(W{j}{k})
                            Wf{j}(:,k)=zeros(N(j),1);
                        elseif strcmp(class(W{j}{k}),'frd')
                            w1=W{j}{k}.Frequency;
                            x1=W{j}{k}.ResponseData;
                            Wf{j}(:,k)=interp1(w1,x1(:),w{j},[],'extrap');
                        else
                            Wf{j}(:,k)=freqresp(W{j}{k},w{j});
                            if k==3, Wf{j}(:,3)=Wf{j}(:,3)./squeeze(Gf{j}(q,q,:)); end
                            if k==4, Wf{j}(:,4)=Wf{j}(:,4).*squeeze(Gf{j}(q,q,:)); end
                        end
                    end
                    
                    Gphif{j,q}= Gphif_construct_MIMO (Gf{j},phif{j},w{j},w{j},q,n,theta_bar(j,:));
                    
                    if isempty(gamma),
                        
                        if ~isempty(nq)
                            [A1 b1]=Ab_HinfCons(Gphif{j,q},Wf{j},Ldf_mat{j}(:,q),nq,lambda);
                        else
                            [A1 b1 HinfConstraint1]=Ab_HinfCons(Gphif{j,q},Wf{j},Ldf_mat{j}(:,q),nq,lambda,rho);
                            HinfConstraint=[HinfConstraint HinfConstraint1];                       
                        end
                        
                        A=[A ; A1];
                        b=[b ; b1];
                        
                    end
                    
                end
            end
            
            
            
            if isempty(gamma),
                Convcons = [HinfConstraint, StabCons ];

                [x,optval,xflag]=solveopt(H,f,A,b,Convcons,YesYalmip,rho,ops);
            else
               % gamma iteration using bisection algorithm
               
               if isempty(nq)
                   nq=8;
               end
               
               Wfgamma=cell(1,m);
               
                gamma_opt=0;
                gamma_opt_old = g_max + g_tol + 1;
                nit = 0;
                
                while gamma_opt_old - gamma_opt > g_tol
                    
                    nit = nit+1;
                   if nit ~= 1
                        if gamma_opt~=0
                            gamma_opt_old = gamma_opt;
                            g_min=options.gamma(1);
                            g_max=gamma_opt;
                            for j=1:m,
                               for q=1:no                              
                                   Ldf_mat{j}(:,q)=transpose(Gphif{j,q})*x_opt;
                               end
                           end
                        else
                            break;
                        end
                    end
                   
                   
               
                   while g_max-g_min > g_tol

                       Ag=[];
                       bg=[];

                       for j=1:m

                           if sum(lambda)==0
                               Wfgamma{j}=inv(gamma)*Wf{j};
                           else

                               for k=1:4,
                                   if lambda(k)~=0
                                       Wfgamma{j}(:,k)=inv(gamma)*Wf{j}(:,k);
                                   else
                                       Wfgamma{j}(:,k)=Wf{j}(:,k);
                                   end
                               end
                           end
                       end

                       for j=1:m

                           for q=1:no
                               [A1 b1]=Ab_HinfCons(Gphif{j,q},Wfgamma{j},Ldf_mat{j}(:,q),nq,lambda);
                               Ag=[Ag ; A1];
                               bg=[bg ; b1];
                           end

                       end
                       Ag=[A;Ag];
                       bg=[b;bg];
                       [x,optval,xflag] = solveopt(H,f,Ag,bg,[],YesYalmip,rho,ops);

                       if xflag==1,

                           x_opt=x;gamma_opt=gamma;optval_opt=optval;xflag_opt=xflag;
                           A_opt=Ag;b_opt=bg;

                           g_max=gamma;

                           disp(['gamma=', num2str(g_max)])
                           gamma=mean([g_min,gamma]);
                           %gamma=mean([options.gamma(1),gamma]);

                           

                       else
                           g_min=gamma;
                           gamma=mean([g_max,gamma]);
                       end

                   end
               end
               
               if gamma_opt~=0
                    x=x_opt;gamma=gamma_opt;optval=optval_opt;xflag=xflag_opt;
                    A=A_opt;b=b_opt;
               else
                    A=Ag;b=bg;
               end
                %--------------------------------------------------------------------------
               
            end            
            
    end
           
    
     
    %----------------------------------------------------------------------
            
    K1=cell(1,Ngs);
    for p=1:ni
        for q=1:no
            
            nn=Ngs*(sum(sum(n(1:p-1,:)))+sum(n(p,1:q-1)));
            for k=1:Ngs
                K1{k}(p,q) = minreal(transpose(x(nn+k:Ngs:nn+Ngs*n(p,q))) * phi{p,q});
            end
        end
    end
    if Ngs==1,
        K=K1{1};
    else
        K=K1;
        fprintf('\n');
        disp('K{1}+theta_1 K{2}+theta_2 K{3} + ... +theta_1^2 k{n}+theta_2^2k{n+1}+...')
        fprintf('\n');
        for k=1:Ngs,
            disp(['K{'  int2str(k) '}=']),K{k}
        end
    end
    
end

sol_info.rho=x;
sol_info.A=A;
sol_info.b=b;
sol_info.optval=optval;
sol_info.gamma=gamma;
sol_info.xflag=xflag;

end

%=============================================================================================
%=============================================================================================


function [A , b] = Ab_construct (phiGfreq , a , d)

% phiGfreq is a matrix of n rows and N columns where n is the number of
% basis functions and N is the number of frequency points. In the column i
% the value of phi(jw)*G(jw) for the i-th frequency is stored.
% 
% a is a 1*2 vector and d is a scalar such that ax=d represents a line in 
% the complex plane. Should a and d be a function of frequency, they must 
% be entered as, repectively, an N*2 matrix and an N*1 vector.  

hh=size(a);
if hh(1)==1
    
    A=-a(1)*real(transpose(phiGfreq))-a(2)*imag(transpose(phiGfreq));

    h=size(phiGfreq);
    N1=h(2);
    b=-d*ones(N1,1);

else
    
    [n , ntoto]=size(phiGfreq);
    
    A=(-a(:,1)*ones(1,n)).*real(transpose(phiGfreq))+(-a(:,2)*ones(1,n)).*imag(transpose(phiGfreq));
    
    b=-d;
    
end

end
%=============================================================================================
%=============================================================================================

function X = Gphif_construct_MIMO (Gf , phif , w , ws , q , n , theta_bar)

[ntoto,ns]=min(abs(w-ws(1)));

N=length(ws);

Ngs=length(theta_bar);

ntot=Ngs*sum(sum(n));

[ntoto , ni]=size(Gf(:,:,1));

X=zeros(ntot,N);


for i=1:ni
    
    x2=zeros(Ngs*n(i,q),N);
    for u=1:n(i,q)
        
        x1(u,:)=Gf(q,i,ns:ns+N-1).*phif{i,q}(u,1,ns:ns+N-1);
        x2((u-1)*Ngs+1:u*Ngs,:)=kron(theta_bar',x1(u,:));
        
    end
    
    v=Ngs*(sum(sum(n(1:i-1,:)))+sum(n(i,1:q-1)));
    X(v+1:v+Ngs*n(i,q),:)=x2;
   
end


end

%=============================================================================================
%=============================================================================================

function [A b] = Ab_for_bounded_K (phif, w, Ku, wh, theta_bar)

% Construts matrix A and vector b for constraint A*rho < b when we want to
% limit the real and imaginary part of the controller K(jw)

if wh >= max(w) | Ku <= 0
    A=[]; b=[];
    return
end

[n , ntoto]=size(phif(:,:,1));
N=length(w);

[ntoto,whn]=min(abs(w-wh));

Ngs=length(theta_bar);


A1=zeros(N-whn+1,Ngs*n); A3=zeros(N-whn+1,Ngs*n);

for u=1:n
    
    toto(u,:)=phif(u,1,:);    
    A1(:,(u-1)*Ngs+1:u*Ngs)=real(kron(theta_bar',toto(u,whn:N))');
    A3(:,(u-1)*Ngs+1:u*Ngs)=imag(kron(theta_bar',toto(u,whn:N))');
   
end
    
A2=-A1;
A4=-A3;

A = [A1 ; A2 ; A3 ; A4];
b= Ku * ones (4*(N-whn+1),1);
end

%=============================================================================================
%=============================================================================================

function [ A b HinfConstraint] = Ab_HinfCons(phiGfreq,Wf,Ldf,nq,lambda,rho)


a(:,1)=real(Ldf)+1;
a(:,2)=imag(Ldf);
A=[];
b=[];
HinfConstraint=[];
[n,m]=size(phiGfreq);

if max(lambda)>0
    
    d=-a(:,1)+(abs(lambda(1)*Wf(:,1))+abs(lambda(4)*Wf(:,4))).*abs(Ldf+1);
    
    if ~isempty(nq)
        if lambda(2)~=0 | lambda(3)~=0
            for q=1:nq
                for j=1:n
                    phiGq(j,:)=phiGfreq(j,:).*(1+(abs(lambda(2)*Wf(:,2))+abs(lambda(3)*Wf(:,3)))*exp(i*2*pi*q/nq)/cos(pi/nq))';
                end
                [A1 b1]= Ab_construct (phiGq , a , d);  % right side of the line a(w).x = d(w)
                A = [A ; A1];
                b = [b ; b1];
            end
        else
            [A1 b1]= Ab_construct (phiGfreq , a , d);  % right side of the line a(w).x = d(w)
            A = [A ; A1];
            b = [b ; b1];
        end

    else
        L=transpose(phiGfreq)*rho;
        for j=1:m
            try
                HinfConstraint=[HinfConstraint,(abs(lambda(1)*Wf(j,1))+abs(lambda(4)*Wf(j,4))+abs(lambda(2)*Wf(j,2)*L(j))...
                +abs(lambda(3)*Wf(j,3)*L(j)))*abs(1+Ldf(j))-real((1+conj(Ldf(j)))*(1+L(j)))<=0];
            catch
                HinfConstraint=HinfConstraint+set((abs(lambda(1)*Wf(j,1))+abs(lambda(4)*Wf(j,4))+abs(lambda(2)*Wf(j,2)*L(j))...
                +abs(lambda(3)*Wf(j,3)*L(j)))*abs(1+Ldf(j))-real((1+conj(Ldf(j)))*(1+L(j)))<0);
            end
        end
    end
    
end


if max(abs(Wf(:,1)))~=0 & lambda(1)==0
    
    d=-a(:,1)+abs(Wf(:,1)).*abs(Ldf+1);
    
    
    [A1 b1]= Ab_construct (phiGfreq , a , d);  % right side of the line a(w).x = d(w)
    A = [A ; A1];
    b = [b ; b1];
    
end


if max(abs(Wf(:,2)))~=0  & lambda(2)==0
    
    if ~isempty(nq)
        for q=1:nq
            for j=1:n
                phiGq(j,:)=phiGfreq(j,:).*(1+abs(Wf(:,2))*exp(i*2*pi*q/nq)/cos(pi/nq))';
            end
            [A1 b1]= Ab_construct (phiGq , a , -a(:,1));  % right side of the line a(w).x = d(w)
            A = [A ; A1];
            b = [b ; b1];
        end
    else
        L=transpose(phiGfreq)*rho;
        for j=1:m,
            try
                HinfConstraint=[HinfConstraint,(abs(Wf(j,2)*L(j)*(1+Ldf(j)))-real((1+conj(Ldf(j)))*(1+L(j)))<=0)];
            catch
                HinfConstraint=HinfConstraint+set(abs(Wf(j,2)*L(j)*(1+Ldf(j)))-real((1+conj(Ldf(j)))*(1+L(j)))<0);
            end
        end
    end
end



if max(abs(Wf(:,3)))~=0 & lambda(3)==0
    
    if ~isempty(nq)
        for q=1:nq
            for j=1:n
                phiGq(j,:)=phiGfreq(j,:).*(1+abs(Wf(:,3))*exp(i*2*pi*q/nq)/cos(pi/nq))';
            end
            [A1 b1]= Ab_construct (phiGq , a , -a(:,1));  % right side of the line a(w).x = d(w)
            A = [A ; A1];
            b = [b ; b1];
        end
    else
        L=transpose(phiGfreq)*rho;
        for j=1:m
            try
                HinfConstraint=[HinfConstraint, abs(Wf(j,3)*L(j)*(1+Ldf(j)))-real((1+conj(Ldf(j)))*(1+L(j)))<=0];
            catch
                HinfConstraint=HinfConstraint+set(abs(Wf(j,3)*L(j)*(1+Ldf(j)))-real((1+conj(Ldf(j)))*(1+L(j)))<0);
            end
        end
    end
    
end

if max(abs(Wf(:,4)))~=0 & lambda(4)==0
    
    
    d=-a(:,1)+abs(Wf(:,4)).*abs(Ldf+1);
    
    [A1 b1]= Ab_construct (phiGfreq , a , d);  % right side of the line a(w).x = d(w)
    A = [A ; A1];
    b = [b ; b1];
end

end


%=============================================================================================
%=============================================================================================

function a= alpha_finder_degree(alpha,l,phase)
        a= 180*acos((1-l)*sind(alpha)^2+cosd(alpha)*sqrt(1-(1-l)^2*sind(alpha)^2))/pi-phase;
end


%=============================================================================================
%=============================================================================================

function [Gf,Gdim,phi,n,phif,phifd,per,w,N,performance,Ldf,LDf,FGf,FLdf,FLDf,CovGf] = condesdata(inG,inphi,inper,options)


% Determining number of models
if ~iscell(inG)
    G{1}=inG;
    m=1;
else
    G=inG;
    m=length(G);
end


% Determining frequency responses of models

w=cell(1,m);
wd=cell(1,m);

Gf=cell(1,m);
CovGf=cell(1,m);

wmax=0;
N=zeros(1,m);

% Determinimg the frequency vector  and the frequency responses for each model

if ~isempty(options.w)
    if ~iscell(options.w)
        for j=1:m
            w{j}=options.w;
        end
    else
        w=options.w;
    end
else
    for j=1:m
        [ntoto,ntoto,w{j}]=bode(G{j});
    end
end

for j=1:m
    
    Gf{j}=freqresp(G{j},w{j});
    CovGf{j}=[];
                
    wmax=max(wmax,max(w{j}));
    wd{j}=linspace(min(w{j}),max(w{j}),1000)'; % This frequency vector is used for approximation of the two norm of F(L-Ld)
end
       
phif=cell(1,m);
per=cell(1,m);

[no ni]=size(G{1});

if no==1 & ni==1  % SISO system
        
    if ~isempty(options.F)
        if ~iscell(options.F)
            for j=1:m
                F{j}=options.F;
            end
        else
            F=options.F;
        end
    end
    
    if strcmp(inphi.ConType,'PID') 
    [num,den]=tfdata(inphi.phi(3),'v');
        if den(1)==0,
            den(1)=1.2/wmax; %default value for tau (time constant of the derivator)
            inphi.phi(3)=tf(num,den);
        end
    end

    if strcmp(inphi.ConType,'PD') 
    [num,den]=tfdata(inphi.phi(2),'v');
        if den(1)==0,
            den(1)=1.2/wmax;  %default value for tau (time constant of the derivator)
            inphi.phi(2)=tf(num,den);
        end
    end
      
    
    phi=inphi.phi;
    [n , ntoto]=size(phi);

        
    
    if ~iscell(inper)
        per(1,:)={inper};
    else
        per=inper;
    end
    
    % Determining frequency response of desired open loop
    LDf=[];FLDf=[];
    
    if isempty(per{1}.Ld)
        Ldf=[];FLdf=[];phifd=[];FGf=[];
    else
        Ldf=cell(1,m);
        Ldfd=cell(1,m);
        FGf=cell(1,m);
        FLdf=cell(1,m);
        phifd=cell(1,m);
         
        for j=1:m
            if strcmp(class(per{j}.Ld),'frd')
                w1=per{j}.Ld.Frequency;
                x=per{j}.Ld.ResponseData;
                Ldf{j}(:,1) = interp1(w1,x(:),w{j},[],'extrap'); % Ldf{j} is a column vector
                Ldfd{j}(:,1) = interp1(w1,x(:),wd{j},[],'extrap'); % Ldfd{j} is a column vector
            else
                Ldf{j}(:,1) = freqresp(per{j}.Ld,w{j}); % Ldf{j} is a column vector
                Ldfd{j}(:,1) = freqresp(per{j}.Ld,wd{j}); % Ldfd{j} is a column vector
            end
        end
               
        
        % In this part F*G and F*Ld are computed for a dense frequency vector
        % wd to compute the two norm of F(L-Ld)=(F*G)*K-F*Ld
        
        for j=1:m,
            if isempty(options.F)
                Ff{j}=1./(1+Ldfd{j});
            else
                if strcmp(class(F{j}),'frd')
                    w1=F{j}.Frequency;
                    x=F{j}.ResponseData;
                    Ff{j}(:,1)=interp1(w1,x(:),wd{j},[],'extrap');
                else
                    if strcmp(class(F{j}),'double'), F{j}=tf(F{j}); end
                    Ff{j}(:,1)=freqresp(F{j},wd{j});
                end
            end
                    
            phifd{j}=freqresp(phi,wd{j});
            

            if strcmp(class(G{j}),'frd') | strcmp(class(G{j}),'idfrd')
                Gfd(:,1)=interp1(w{j},squeeze(Gf{j}),wd{j});
            else
                Gfd(:,1)=freqresp(G{j},wd{j});
            end
            
                                 
            FGf{j}=Ff{j}.*Gfd;
            FLdf{j}=Ff{j}.*Ldfd{j};
            
        end
    end

    for j=1:m
        phif{j}=freqresp(phi,w{j});
        if isempty(Ldf)
            [phif{j},Gf{j},Ldf,w{j}]=removeInf(phif{j},Gf{j},Ldf,w{j});
        else
        [phif{j},Gf{j},Ldf{j},w{j}]=removeInf(phif{j},Gf{j},Ldf{j},w{j});
        [phifd{j},FGf{j},FLdf{j}]=removeInf(phifd{j},FGf{j},FLdf{j},[]);
        end
        if strncmp(class(G{j}),'id',2)
            [ntoto,ntoto,CovGf{j}]=freqresp(G{j},w{j});
        end
        
        N(j)=length(w{j}); % lengths of frequency vectors
    end
 
    performance=per{1}.PerType;
    
else % if MIMO
    
    
    phi=cell(ni,no);
    if ~iscell(inphi)
        if strcmp(inphi.ConType,'PID') 
            [num,den]=tfdata(inphi.phi(3),'v');
            if den(1)==0,
                den(1)=1.2/wmax; %default value for tau (time constant of the derivator)
                inphi.phi(3)=tf(num,den);
            end
        end

        if strcmp(inphi.ConType,'PD') 
            [num,den]=tfdata(inphi.phi(2),'v');
            if den(1)==0,
                den(1)=1.2/wmax;  %default value for tau (time constant of the derivator)
                inphi.phi(2)=tf(num,den);
            end
        end
        
        
        phi(:,:)={inphi.phi};
    else
        
        for p=1:ni
            for q=1:no
                if strcmp(inphi{p,q}.ConType,'PID') 
                    [num,den]=tfdata(inphi{p,q}.phi(3),'v');
                    if den(1)==0,
                       den(1)=1.2/wmax; %default value for tau (time constant of the derivator)
                       inphi{p,q}.phi(3)=tf(num,den);
                    end
                end

                if strcmp(inphi{p,q}.ConType,'PD') 
                    [num,den]=tfdata(inphi{p,q}.phi(2),'v');
                    if den(1)==0,
                       den(1)=1.2/wmax;  %default value for tau (time constant of the derivator)
                       inphi{p,q}.phi(2)=tf(num,den);
                    end
                end
                
               
                phi{p,q}=inphi{p,q}.phi;
            end
        end
    end
    n=zeros(ni,no);
    for p=1:ni
        for q=1:no
            [n(p,q) , ntoto]=size(phi{p,q});
        end
    end
    
    for j=1:m
         for p=1:ni
            for q=1:no
                phif{j}{p,q}=freqresp(phi{p,q},w{j});                
                phifd{j}{p,q}=freqresp(phi{p,q},wd{j});
             end
        end
    end
    
    if ~iscell(inper)
        for j=1:m
            for q=1:no
                per{j}{q}=inper;
            end
        end
    elseif ~iscell(inper{1})
        for j=1:m
            per{j}=inper;
        end
    else
        per=inper;
    end
    
       
    
    Ldf=[];FLdf=[];
    LDf=cell(1,m);
    if isempty(per{1}{1}.Ld)
        error ('You must specify Ld for MIMO models.');
    else
        for j=1:m
            for q=1:no
                if strcmp(class(per{j}{q}.Ld),'frd')
                    w1=per{j}{q}.Ld.Frequency;
                    x=per{j}{q}.Ld.ResponseData;
                    LDf{j}(q,q,:) = interp1(w1,x(:),w{j},[],'extrap'); % LDf{j} is a 3-D array
                    LDfd{j}(q,q,:) = interp1(w1,x(:),wd{j},[],'extrap'); % LDfd{j} is a 3-D array
                else
                    LDf{j}(q,q,:)=freqresp(per{j}{q}.Ld,w{j});  % LDf{j} is a 3-D array
                    LDfd{j}(q,q,:)=freqresp(per{j}{q}.Ld,wd{j});  % LDfd{j} is a 3-D array
                end
            end
        end
    
    end
     
    
    if ~isempty(options.F)
        if ~iscell(options.F)
            for j=1:m
                for q=1:no
                    F{j}{q}=options.F;
                end
            end
        elseif ~iscell(options.F{1})
            for j=1:m
                F{j}=options.F;
            end
        else
            F=options.F;
        end
    end
      
    
    % In this part F*G and F*Ld are computed for a dense frequency vector
    % wd to compute the two norm of F(L-Ld)=(F*G)*K-F*Ld
    
    FGf=cell(1,m);
    Ff=cell(1,m);
    FLDf=cell(1,m);
    
    for j=1:m,
        FGf{j}=zeros(no,ni,length(wd{j}));
        
        if strcmp(class(G{j}),'frd')
            w1=G{j}.Frequency;
            x1=G{j}.ResponseData;
            for p=1:ni
                for q=1:no
                    Gfd(q,p,:)= interp1(w1,squeeze(x1(q,p,:)),wd{j},[],'extrap');
                end
            end
            
        else
            Gfd=freqresp(G{j},wd{j});
        end
        
        for q=1:no
            
            if isempty(options.F)
                Ff{j}(q,q,:)=1./(1+LDfd{j}(q,q,:));
            else
                if ~iscell(F{j})
                    F{j}{q}=F{j};
                end
                if strcmp(class(F{j}{q}),'frd')
                    w1=F{j}{q}.Frequency;
                    x=F{j}{q}.ResponseData;
                    Ff{j}(q,q,:)=interp1(w1,x(:),wd{j},[],'extrap');
                else
                    Ff{j}(q,q,:)=freqresp(F{j}{q},wd{j});
                end
            end
            
            FLDf{j}(q,q,:)=Ff{j}(q,q,:).*LDfd{j}(q,q,:);
            
            for p=1:ni                 
                FGf{j}(q,p,:)=Ff{j}(q,q,:).*Gfd(q,p,:);
            end
            
        end
    end
    
    for j=1:m
        
%         [phif{j},Gf{j},LDf{j},w{j}]=removeInf(phif{j},Gf{j},LDf{j},w{j});
%         [phifd{j},FGf{j},FLDf{j}]=removeInf(phifd{j},FGf{j},FLDf{j},[]);
        N(j)=length(w{j}); % lengths of frequency vectors
    end
    
    
    
    performance = per{1}{1}.PerType;
end

Gdim=[m , no , ni];
end


%=============================================================================================
%=============================================================================================

function [x , optval, xflag] = solveopt (H,f,A,b,ConvCons,YesYalmip,rho,ops)

if YesYalmip==1,
    
    if isempty(H),
        objectif=f'*rho;
    else
        objectif=0.5*rho'*H*rho+f'*rho;
    end
    
    if ~isempty(A)
        try
            Constraint=[ConvCons, (A*rho < b)];
        catch
            Constraint=[ConvCons set(A*rho < b)];
        end
    else
        Constraint=ConvCons;
    end
    
    optval = solvesdp(Constraint , objectif , ops);
    
    if optval.problem==0
        xflag=1;
    else
        xflag=0;
    end
    
    disp(yalmiperror(optval.problem))
    
    x=double(rho);
       
else
    if isempty(H),
        [x,optval,xflag] = linprog(f,A,b,[],[],[],[],[],ops);
    else
        [x,optval,xflag] = quadprog(H,f,A,b,[],[],[],[],[],ops);
    end
end


end

%=============================================================================================
%=============================================================================================

function [A,b]=gain_bound_MIMO(phif,w,Ku,wh,theta_bar,Gdim,ntot,rhoIndex)
    
    A=[];
    b=[];
    m=Gdim(1); no=Gdim(2); ni=Gdim(3);
    
    [p0,q0]=size(Ku);
    if p0==1 & q0==1
        Ku=Ku*ones(ni,no);
    elseif p0~=ni | q0~=no
        error('Ku should be a scalar or a matrix with the same size of the controller')
    end
    
    [p0,q0]=size(wh);
    if p0==1 & q0==1
        wh=wh*ones(ni,no);
    elseif p0~=ni | q0~=no
        error('wh should be a scalar or a matrix with the same size of the controller')
    end
    
    for j=1:m
        
        for p=1:ni
            for q=1:no
                
                [A_b1 b_bounding] = Ab_for_bounded_K (phif{j}{p,q}, w{j}, Ku(p,q), wh(p,q), theta_bar(j,:));
                
                [h1,ntoto]=size(A_b1);
                A_bounding=zeros(h1,ntot);
                A_bounding(:,rhoIndex{p,q})=A_b1;
                
                A= [A ; A_bounding];
                b= [b ; b_bounding];                
 
            end
        end
    end

end
%=============================================================================================
%=============================================================================================

function [phi,G,Ld,w]=removeInf(phi,G,Ld,w)
    % This function removes any row of phi,G,Ld,w that contain Inf or NaN
   
    
    if length(size(squeeze(G)))==2
        index=all(isfinite(squeeze(G)),2);
    else
        index=all(isfinite(sum(G)),2);
    end
  
    if ~isempty(Ld)
        if length(size(squeeze(Ld)))==2
            index=and(index,all(isfinite(squeeze(Ld)),2));
        else
            index=and(index,all(isfinite(sum(Ld)),2));
        end
    end
    if iscell(phi)
        [ni,no]=size(phi);

        for p=1:ni
            for q=1:no
                index=and(index,all(isfinite(sum(phi{p,q})),2));
            end
        end
    else
        index=and(index,squeeze(all(isfinite(sum(phi)),2)));
    end

    if ~isempty(w)
        w=w(squeeze(index));
    end
    
    if ~isempty(Ld)
        if length(size(squeeze(Ld)))==2
            Ld=Ld(squeeze(index));
        else
            Ld=Ld(:,:,index);
        end
    end
    
    if length(size(squeeze(G)))==2
        G=G(squeeze(index));
    else
        G=G(:,:,index);
    end
    

    if iscell(phi)
        for p=1:ni
            for q=1:no
                phi{p,q}=phi{p,q}(:,:,index);
            end
        end
    else
        phi=phi(:,:,index);
    end
           
end


function sgn = test_PID_ss_gain(Gf,w)
    for i=1:length(Gf)
        ss(i) = Gf{i}(1,1,1);
        w_ss(i) = w{i}(1);
    end
    
    if sum(real(ss)) == sum(abs(real(ss))) %% low frequency gains are all positive
        sgn = -1;
    elseif sum(real(ss)) == -sum(abs(real(ss))) %% low frequency gains are all negative
        sgn = 1;
    else
        sgn = -1;
        warning('Some models have a positive low-frequency gain and some negative. Assuming stabilizing Ki/Kp is positive.')
    end
end



function K = reduced_order(rhox,phi,ConType)

if ~isempty(strfind(ConType,'Laguerre')) || ~isempty(strfind(ConType,'generalized'))
    lcd = zpk([],phi.p(end),1,phi.Ts);
    K = minreal(rhox' * minreal(phi/lcd)*lcd);
    
    n = length(phi.p{end});
    order = length(pole(K));
    tol = eps;
    k = 2;
    while order > n
        if tol > 1e-6
            break;
        end
        tol = k*tol;
        K = minreal(K,tol);
        order = length(pole(K));       
    end
else
    K = minreal(rhox' * phi);
end

end


function [] = check_Ld_stability(per,inG,phi)
if ~iscell(inG)
    inG = {inG};
end

for m=1:length(inG)
    G = inG{m};
    Ld = per{m}.Ld;
    
    if ~isempty(Ld)

        if isa(G,'frd') || isa(Ld,'frd')
            continue;
        end

        % Check that Ld is strictly proper
        if isdt(Ld)
            var = tf('z');
        else
            var = tf('s');
        end
        if ~isproper(Ld*var)
            warning('MATLAB:RCTLdproper','Ld does not appear to be strictly proper.');
            return;
        end

        % Check closed-loop stability of Ld
        CLd = feedback(1,Ld);
        if isdt(CLd)
            x = isstable(absorbDelay(CLd));
        elseif isa(CLd,'ss') && ~isempty(CLd.InternalDelay) && CLd.InternalDelay ~= 0
            x = isstable(pade(CLd,10));
        else
            x = isstable(CLd);
        end
        if x==0
            warning('MATLAB:RCTLdstable','Ld appears to be closed-loop unstable.')
        end
        
        
        % Make sure G and phi are both continuous/discrete
        if isdt(phi)
            if isdt(G) && phi.Ts~=-1
                G = d2d(G,phi.Ts);
            else
                G = c2d(G,phi.Ts);
            end
        elseif isdt(G)
            G = d2c(G);
        end


        % get poles on stability boundary of Phi
        Phi = zpk([],[],0,phi.Ts);
        for i=1:size(phi,1)
            Phi = Phi + zpk([],pole(phi(i)),1,phi.Ts);
        end
        Phi = minreal(Phi); % lowest common denominator of phi
        [~,pphi_bd] = getpoles(Phi);

        % get poles of G
        [n_uns,p_bd] = getpoles(G);

        % combine poles of G and phi and sort
        p_bd = sort([p_bd; pphi_bd]);

        % Make sure Ld and G are both continuous/discrete before computing
        % poles
        if isdt(G)
            if isdt(Ld)
                Ld = d2d(Ld,G.Ts);
            else
                p=pole(Ld);
                LdA = zpk([],p(real(p)==0),1); % containing poles on boundary
                LdB = minreal(Ld/LdA); % no poles on boundary
                Ld = c2d(LdA,G.Ts) * c2d(LdB,G.Ts); % split Ld to avoid numerical problems with poles on boundary
            end
        elseif isdt(Ld)
            Ld = d2c(Ld);
        end
        [nL_uns,pL_bd] = getpoles(Ld);
        pL_bd = sort(pL_bd);

        delta = 1e-6;
        if length(p_bd)~=length(pL_bd) || sum(abs(p_bd-pL_bd)>delta)~=0
            warning('MATLAB:RCTLdboundarypoles','Ld does not appear to contain the poles of G*K on the stability boundary. This choice of Ld may generate a destabilizing controller.')
        end
        if n_uns~=nL_uns
            warning('MATLAB:RCTLdunstablepoles','Ld and G*K should have the same number of unstable poles, but it appears that Ld has %i and G{%i}*K has %i. This choice of Ld may generate a destabilizing controller.',nL_uns,m,n_uns)
        end
    end
        
end

end


function [n_uns,p_bd] = getpoles(G)
% Function to return the number of unstable poles of sys G and the location
% of poles on the stability boundary. If model has internal delays, use
% 10th order Pade approximation to check stability.
delta = eps; % numerical tolerance of MATLAB
if isdt(G)
    p = pole(absorbDelay(G));
    n_uns = sum(abs(p)-1>delta);
    p_bd = p(abs(abs(p)-1)<delta);
else
    if isa(G,'ss') && ~isempty(G.InternalDelay) && sum(G.InternalDelay) ~= 0
%         disp('Model has internal delays. Using a 10th order Pade approximation to check stability.');
        p = pole(pade(G,10));
    else
        p = pole(G);
    end
    n_uns = sum(real(p)>delta);
    p_bd = p(abs(real(p))< delta);
end
end



